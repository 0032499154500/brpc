[中文版](../cn/thrift.md)

[thrift](https://thrift.apache.org/)is a RPC framework used widely in production environment which was developed by Facebook. In order to access thrift servers more conveniently and make full use of concurrency ability of bthread, brpc directly supports the thrift protocol.
Check [example/thrift_extension_c++](https://github.com/brpc/brpc/tree/master/example/thrift_extension_c++/) for an example.

Advantages compared to the official thrift client:
- Thread safety. No need to set up separate clients for each thread.
- Supports synchronous, asynchronous, batch synchronous, batch asynchronous, and other access methods. Combination channels such as ParallelChannel are also supported.
- Support various connection types(short, connection pool). Support timeout, backup request, cancellation, tracing, built-in services, and other benefits offered by brpc.

# Compile and Run
In order to not depend on and compile with thrift library for most users, the thrift protocol wasn't supported in brpc by default. Configure brpc with --with-thrift if you want to enable thrift protocol in brpc.

Install Thrift in Ubuntu
```bash
Download thrift source code from offical [web site](https://thrift.apache.org/download)
wget http://www.us.apache.org/dist/thrift/0.11.0/thrift-0.11.0.tar.gz
tar -xf thrift-0.11.0.tar.gz
cd thrift-0.11.0/
./configure --prefix=/usr --with-ruby=no --with-python=no --with-java=no --with-go=no --with-perl=no --with-php=no --with-csharp=no --with-erlang=no --with-lua=no --with-nodejs=no
make CPPFLAGS=-DFORCE_BOOST_SMART_PTR -j 3 -s
sudo make install
```
Debian please refer [offical wiki]](https://thrift.apache.org/docs/install/debian)

Configure with thrift support
```bash
sh config_brpc.sh --headers=/usr/include --libs=/usr/lib --nodebugsymbols --with-thrift
```
Thrift extension was supported via static library, libbrpc.a was generated after compile, link with it if users want to enable thrift protocol.

# Thrift message definition, echo.thrift:
```c++
namespace cpp example

struct EchoRequest {
    1: required string data;
    2: required i32 s;
}

struct EchoResponse {
    1: required string data;
}

service EchoService {
    EchoResponse Echo(1:EchoRequest request);
}
```


# Client asscess thrift server

create a Channel to access thrift server:

```c++
#include <brpc/channel.h>
#include <brpc/details/thrift_utils.h>
#include <brpc/thrift_message.h>
...

DEFINE_string(server, "0.0.0.0:8019", "IP Address of thrift server");
DEFINE_string(load_balancer, "", "The algorithm for load balancing");
...
  
brpc::ChannelOptions options;
options.protocol = brpc::PROTOCOL_THRIFT;
brpc::Channel thrift_channel;
if (thrift_channel.Init(Flags_server.c_str(), FLAGS_load_balancer.c_str(), &options) != 0) {
   LOG(ERROR) << "Fail to initialize thrift channel";
   return -1;
}
...
```
Construct a thrift request and send it to server, ThriftMessage is a template class that hosts thrift navtive messages, raw() methods can directly manipulate native thrift messages.

```c++
 // wrapper thrift raw request into ThriftMessage
 // example::[EchoRequest/EchoResponse]is thrift native message generated by thrift toolkits
 brpc::ThriftMessage<example::EchoRequest> req;
 brpc::ThriftMessage<example::EchoResponse> res;

 req.raw().data = "hello";

 cntl.set_thrift_method_name("Echo");

 channel.CallMethod(NULL, &cntl, &req, &res, NULL);

 if (cntl.Failed()) {
     LOG(ERROR) << "Fail to send thrift request, " << cntl.ErrorText();
     return -1;
 } 
```

# Server side processing upstream thrift requests
Users need to implement their own thrift handler which was inherited from brpc::ThriftService.
Due to the limitation of thrift protocol itself, only the method name can be obtained on the server (via the controller.thrift_method_name() method), and the service name cannot be obtained. This is consistent with the native thrift implementation, which means that there can only be one thrift service in one brpc server.
```c++
// Implement User Thrift Service handler
class MyThriftProtocolPbManner : public brpc::ThriftService {
public:
    void ProcessThriftFramedRequest(const brpc::Server&,
                              brpc::Controller* cntl,
                              brpc::ThriftMessage* request,
                              brpc::ThriftMessage* response,
                              brpc::ThriftClosure* done) {
        // This object helps you to call done->Run() in RAII style. If you need
        // to process the request asynchronously, pass done_guard.release().
        brpc::ClosureGuard done_guard(done);

        if (cntl->Failed()) {
            // NOTE: You can send back a response containing error information
            // back to client instead of closing the connection.
            cntl->CloseConnection("Close connection due to previous error");
            return;
        }

        example::EchoRequest* req = request->Cast<example::EchoRequest>();
        example::EchoResponse* res = response->Cast<example::EchoResponse>();

        // process with req and res
        res->data = req->data + "user data";

        LOG(INFO) << "success to process thrift request in brpc with pb manner";

    }

};
```

Register thrift service and start brpc server
```c++
brpc::Server server;
    brpc::ServerOptions options;
    options.thrift_service = new MyThriftProtocolPbManner;
    options.idle_timeout_sec = FLAGS_idle_timeout_s;
    options.max_concurrency = FLAGS_max_concurrency;

    // Start the server.
    if (server.Start(FLAGS_port, &options) != 0) {
        LOG(ERROR) << "Fail to start EchoServer";
        return -1;
    }
```