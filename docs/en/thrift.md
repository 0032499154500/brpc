[中文版](../cn/thrift.md)

[thrift](https://thrift.apache.org/)is a RPC framework used widely in production area which was developed by Facebook, In order to access thrift servers more conveniently and make full use of bthread's capability of concurrency, brpc directly supports the thrift protocol.
Check [example/thrift_extension_c++](https://github.com/brpc/brpc/tree/master/example/thrift_extension_c++/) for an example.

Advantages compared to the official thrift client:
- Thread safety. No need to set up separate clients for each thread.
- Support synchronous, asynchronous, semi-synchronous accesses etc. Support [ParallelChannel etc](combo_channel.md) to define access patterns declaratively.
- Support various connection types(short, connection pool). Support timeout, backup request, cancellation, tracing, built-in services, and other benefits offered by brpc.

# Compile and Run
In order to not depend on and compile with thrift library for most of the users, the thrift protocol wasn't supported in brpc by default. configure brpc with --with-thrift if you want to enable thrift protocol in brpc(actually it works with a Macro ENABLE_THRIFT_FRAMED_PROTOCOL)

Install Thrift in Ubuntu
```bash
wget http://www.us.apache.org/dist/thrift/0.9.3/thrift-0.9.3.tar.gz
tar -xf thrift-0.9.3.tar.gz
cd thrift-0.9.3/
./configure --prefix=/usr --with-ruby=no --with-python=no --with-java=no --with-go=no --with-perl=no --with-php=no --with-csharp=no --with-erlang=no --with-lua=no --with-nodejs=no
make -j 3 -s
sudo make install
```
Configure with thrift support
```bash
sh config_brpc.sh --headers=/usr/include --libs=/usr/lib --nodebugsymbols --with-thrift
```
Link with libbrpc_thrift.a if the user want to enable thrift protocol

# Thrift message definition, echo.thrift:
```c++
namespace cpp example

struct EchoRequest {
    1: required string data;
    2: required i32 s;
}

struct EchoResponse {
    1: required string data;
}

service EchoService {
    EchoResponse Echo(1:EchoRequest request);
}
```


# Client asscess thrift server

create a Channel to access thrift server:

```c++
#include <brpc/channel.h>
#include <brpc/details/thrift_utils.h>
#include <brpc/thrift_message.h>
...

DEFINE_string(server, "0.0.0.0:8019", "IP Address of thrift server");
DEFINE_string(load_balancer, "", "The algorithm for load balancing");
...
  
brpc::ChannelOptions options;
options.protocol = brpc::PROTOCOL_THRIFT;
brpc::Channel thrift_channel;
if (thrift_channel.Init(Flags_server.c_str(), FLAGS_load_balancer.c_str(), &options) != 0) {
   LOG(ERROR) << "Fail to initialize thrift channel";
   return -1;
}
...
```
construct thrift request and send to server, ThriftTemplateMessage is a template class, the native thrift message was delegated by and can be accessed directly by raw() method.

```c++
 // wrapper thrift raw request into ThriftMessage
 // example::[EchoRequest/EchoResponse]is thrift native message generated by thrift toolkits
 brpc::ThriftTemplateMessage<example::EchoRequest> req;
 brpc::ThriftTemplateMessage<example::EchoResponse> res;

 req.raw().data = "hello";

 cntl.set_thrift_method_name("Echo");

 channel.CallMethod(NULL, &cntl, &req, &res, NULL);

 if (cntl.Failed()) {
     LOG(ERROR) << "Fail to send thrift request, " << cntl.ErrorText();
     return -1;
 } 
```

# Server process with thrift message
User need to implement it's own thrift handler which was inherited from brpc::ThriftService
Only the method name can obtained in server side due to the limit of thrift protocol itself, the service name wasn't passed to server actually, it means that only one thrift service can be set in one brpc server
```c++
// Implement User Thrift Service handler
class MyThriftProtocolPbManner : public brpc::ThriftService {
public:
    void ProcessThriftFramedRequest(const brpc::Server&,
                              brpc::Controller* cntl,
                              brpc::ThriftMessage* request,
                              brpc::ThriftMessage* response,
                              brpc::ThriftClosure* done) {
        // This object helps you to call done->Run() in RAII style. If you need
        // to process the request asynchronously, pass done_guard.release().
        brpc::ClosureGuard done_guard(done);

        if (cntl->Failed()) {
            // NOTE: You can send back a response containing error information
            // back to client instead of closing the connection.
            cntl->CloseConnection("Close connection due to previous error");
            return;
        }

        example::EchoRequest* req = request->cast<example::EchoRequest>();
        example::EchoResponse* res = response->cast<example::EchoResponse>();

        // process with req and res
        res->data = req->data + "user data";

        LOG(INFO) << "success to process thrift request in brpc with pb manner";

    }

};
```

Register thrift service and start brpc server
```c++
brpc::Server server;
    brpc::ServerOptions options;
    options.thrift_service = new MyThriftProtocolPbManner;
    options.idle_timeout_sec = FLAGS_idle_timeout_s;
    options.max_concurrency = FLAGS_max_concurrency;

    // Start the server.
    if (server.Start(FLAGS_port, &options) != 0) {
        LOG(ERROR) << "Fail to start EchoServer";
        return -1;
    }
```